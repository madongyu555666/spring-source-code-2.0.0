1：在Java中为什么不允许从静态方法中访问非静态变量？
* 简答：静态方法属于类的方法，非静态变量属于类的实例对象，需要对象自己产生，然后通过类的实例对象去访问。静态方法和静态变量保存一份，归该类的所有实例对象所共享。因此先加载好的类方法是无法访问后续才创建好的类实例对象的变量的。
* JVM：类信息(Class<?>) ，是当需要这个类的时候，由jvm的类加载器来加载，加载后的类信息存放在JVM的方法区中，包含了类的定义，静态变量，静态方法等元数据信息；非静态变量(即实例变量)是在对象创建时，即new对象的时候，由jvm在堆中分配内存，并给实例变量的非静态属性进行初始化赋值，每个对象的非静态变量都归属本对象，多个实例对象的非静态属性独立不冲突。
* 生活：人(类，抽象出来的一个定义)，这个定义存在于"百科字典"(JVM方法区)中，人(类)有公共(静态)的行为(方法) 和 非公共(非静态)的行为(方法) 及 非公共(静态)的特征(属性)，人(类) 会创建大量的具体个体(实例), 每个人(实例)都会有自己专属的特征(非静态变量)，比如身高，体重。。。每个人(实例)的这些属性归自己所有，互相之间不共享，对于人(类)这个优先的定义(类定义)也无法访问后来根据他这个模板(Class<?>)创建(new)的一个个的具体实例的独享信息(非静态变量)，因为没有访问的必要，这么多也不知道要访问哪一个。
* 设计模式：工作中，如果一个方法是归于类所有，比如我们常用的StingUtil，DateUtil，及单例模式中的全局访问点getInstance()，我们会把这些方法设计为静态方法，JVM中只存一份，节省空间，归全局共享；对于每个对象都需要单独维护的属性和方法，就要是非静态方法，比如我们写的每一个接口，每一个Service，是归属于对象自身所有的，每个请求都有一个专属的对象去处理，互相之间不冲突，不共享。

2：软件架构中的上层应用是指那些层，客户端属于上层应用吗？
* 简答：上下是相对来说的，上层指的是在某个场景下，本层应用的调用层，或者说是当前层的使用层，客户端在调用服务端的时候，客户端在这个场景下可以称为是上层应用，但是当服务端主动推送消息给客户端端时，在推送这个场景下，服务端反而充当了上层的角色。
* 生活：优秀是相对的，你有100元，另外一个人只有10元，相对他，你是上层，但是还有一个人，人家有1W元，这时候你是下层，人家是上层；一切都是相对的，上下，前后，左右。
* 框架：比如常用的MVC三层架构，相对来讲，视图层View是数据层Model的上层；CS模型中，Client和Service也是相对的，互相调用，角色会互相转化。
* 设计模式：代理模式中，代理对象是被代理对象的上层，因为被代理对象都最后由代理对象持有引用后进行调用，属于上层调用下层；装饰器模式中，装饰对象是被装饰对象的上层.