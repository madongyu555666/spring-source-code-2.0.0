你觉得原型模式能够给你解决的最大的麻烦是什么？
* 一句话：原型模式主要目的是在考虑性能的前提下创建重复对象。

* 场景：>在工作中，如果一个对象的创建成本较大(如初始化需要占用较长的时间，占用太多的CPU资源或者网络资源)，那么新的对象就可以通过原型模式对已有对象进行复制来获得，如果是相似对象，可以在复制后对其变量稍作修改即可使用。
>我们日常开发中的简单对象，比如只有几个简单属性的对象，对象创建过程简单，不适于使用原型模式，如果要新对象，直接new就可以，原型模式本身考虑的就是性能和便捷的平衡。

* 实际：我之前开发的一个项目，有一个规则体对象(RuleInfo)，这个对象除了基本的属性(名称，备注，时间等等)属性之外，还有一些复杂的属性，这些属性本身是另外的对象，有规则项集合(List<Item>)，有规则使用历史集合(List<RuleHistory>)等等，在整体层面来说，这个规则对象类似于是一个数据包；在版本迭代中，我接到了一个需求，规则拷贝，拷贝完之后的规则作为新规则二次修改后即可投入使用，这个就是典型的原型模式的应用场景，使用原型模式将目标对象clone()，然后将里面业务独立的属性(比如使用历史List)重置即可。我们可以设想，如果不使用原型模式该怎么做，我们需要先new对象，new完之后还需要new里面的属性对象，然后还要根据原来的对象的属性一个个来设置新对象的属性，代码量大，容易出错，更严重的问题是，如果之后任何对象新加属性，都需要来维护拷贝的代码，这个是很不专业的做法。

* 简述：原型模式对应单例模式，因此原型模式又可以称为是多例模式；
>优点：使用原型模式可以提高对象拷贝性能，因为直接clone()即可，因此可以逃避构造函数的约束。无视对象本身，拷贝逻辑独立，对象增加新属性时无需修改拷贝代码。
>缺点：1：>需要为每个要拷贝的类配备克隆方法，这个方法位于类的内部，如果要实现拷贝，就需要修改类的源代码，违背"开闭原则"。
2：>java中的对象实现Cloneable接口，重写clone()即可拷贝对象，但是默认为浅拷贝，可以使用序列化和反序列化过程来实现深拷贝，当然也可以自己重写clone()的拷贝过程。

* 生活：1>细胞分裂；
2>Tom老师讲的孙悟空毫毛变猴子；
3>我们玩的小游戏中的一些元素，比如云朵，石头，为了提升性能，大多都是使用原型模式和享元模式。